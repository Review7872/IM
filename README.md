# 总结

[项目简介](#1)

[初始架构思想](#2)

[细节思路](#3)

[技术选型](#4)

[设计方案关键点的分析](#5)

[系统架构图](#6)

[消息传输协议](#7)

[碰到的问题以及解决方法](#8)

[接口文档](#9)

[后续项目拓展思路](#10)

# <span id="1">1 **实时通讯与消息推送系统**</span>

一套基于微服务架构与网络通信的实时通讯平台，实现了用户注册、登录、在线即时通讯、离线消息推送等功能。本系统通过高效的消息传递机制和灵活的架构设计，保障了高并发环境下的用户体验和消息准确性。

# <span id="2">2 初始架构思想</span>

1.用户注册请求将直接打在**用户注册**的微服务组件上

2.用户登录将由**gateway**前往**用户**的微服务组件上判断身份，身份正确则选择一个netty集群节点信息然后颁发携带用户个人信息、netty节点信息的**token**并且将**token**存储于**Redis**

3.用户正式登录会尝试与**netty集群**建立连接

4.连接请求将携带**token**进入**gateway**，若**token**有效则会解析token拿到netty节点信息并且将此连接请求转发给此节点

5.**netty集群**节点接受到用户请求后将成功与用户建立连接并且将用户token存入redis，此时用户成功进入主界面，**netty集群**等待转发消息给用户

6.用户进入主界面后会发送普通请求给服务器，拉取个人信息，好友列表

7.用户发送消息时，会携带接受消息人员信息、消息内容、token发送普通请求给服务器

8.若是token信息有效，**gateway**便会将消息的全部信息放入**消息待处理层**

9.**消息待处理层**会将消息转发给相应的**netty集群**节点，并且将全部消息放入**消息存储mq**，若是redis没有另一方token则将消息放入**离校消息mq**

10.mq下层会对消息做进一步处理

11.mq下层1：**消息存储服务**将消息存储入es数据库（做双层存储即可实现撤回消息功能）

12.mq下层2：**离线消息服务**将消息的接收方、接受时间、消息体放入Redis的zset数据类型并且做3天过期处理

13.用户上线后便会自动发送普通请求前往**离线消息服务**拉取离线消息

# <span id="3">3 细节思路</span>

1.netty集群的唯一作用即是发送消息给用户，除此之外用户获取消息的其他两种方式为：上线自动获取3天内离校消息、查看历史记录

2.由于redis会存储离线消息，则要做数据持久化处理

3.每条消息都将根据发送时间与消息体生成全局唯一的hash码作为消息id，消息id将作为zset的member存储入redis（时间为score）并且一并存储入es

4.用户数据库会存储用户信息，用户好友信息

5.消息待处理层的出现是为了让具体服务与网关层**解耦合**，方便**扩展**业务等等

# <span id="4">4 技术选型</span>

### 1 微服务框架
- **Dubbo、SpringCloudAlibaba**

### 2 数据存储与缓存
- **关系数据库**：**MySQL**
- **全文搜索引擎**：**Elasticsearch**
- **缓存数据库**：**Redis**

### 3 消息中间件
- **RocketMQ**

### 4 通信框架
- **Netty**

### 5 微服务组件
- **服务注册：Nacos**
- **流量防卫兵：Sentinel**
- **调用链跟踪：SkyWalking**
- **微服务网关：SpringCloudGateway**

### 6 前端 Web 技术栈
- **前端框架：Vue.js**
- **UI 组件库：Element UI**
- **CSS 框架：Tailwind CSS**

# <span id="5">5 设计方案关键点的分析</span>

1. **用户管理服务**：
   - 用户注册请求直击“用户注册”微服务，用于验证和存储用户信息。
   - 用户登录过程通过Gateway路由至“用户”微服务进行身份验证，验证成功后通过Netty集群节点信息颁发Token，并存储于Redis，实现快速验证和会话管理。

2. **Netty集群**：
   - Netty作为一个高性能的NIO框架，在这里被用来搭建TCP/WS等长连接服务，负责与客户端保持实时通讯。
   - 登录成功后，用户与选定的Netty节点建立连接，Netty节点也会在Redis中保存用户的连接状态和Token信息。

3. **Gateway服务**：
   - Gateway作为统一入口，承担了路由、鉴权和负载均衡的角色，确保只有合法用户才能访问特定服务，并按照Token中的信息将连接请求分发至正确的Netty节点。

4. **消息传输机制**：
   - 用户的消息发送操作首先经过Gateway鉴权，有效Token则将消息转发至对应的Netty节点进行消息转发。
   - 消息在转发前先被放入“消息待处理层”，这一设计有利于解耦业务逻辑和服务间交互，同时也便于扩展新的业务场景，如红包服务或分布式锁秒杀等高并发场景。

5. **消息存储与检索**：
   - 使用MQ作为消息中间件，所有消息先暂存于MQ中，再分别由“消息存储服务”和“离线消息服务”进行处理。
   - “消息存储服务”将消息写入Elasticsearch数据库，用于消息搜索、查询和撤回功能。
   - “离线消息服务”将离线消息存储在Redis的有序集合（ZSet）中，根据接收时间和消息ID排序，并设置过期时间（3天），以便用户上线时能快速拉取最近的离线消息。

6. **持久化与扩展性**：
   - Redis不仅用于存储Session信息和离线消息，还需要考虑其数据持久化策略，确保即使Redis重启也能恢复离线消息。
   - 整个架构设计充分体现了微服务理念，各个模块独立且可扩展，当需要增加新功能或优化已有服务时，不会影响整体架构稳定性。

# <span id="6">6 系统架构图</span>

![](https://picgotuchaung.oss-cn-beijing.aliyuncs.com/202403210847117.png)

# <span id="7">7 消息传输协议</span>

```java
public class Msg {
	// 消息类型
    private int type;
    // 消息发送者
    private String msgSender;
    // 消息接收者
    private String msgReceiver;
    // 消息内容
    private String msg;
}
```

### 1xx 用户消息

##### 101 好友消息

{
  "type": 101,
  "msgSender": "发送者key",
  "msgReceiver": "接收者key",
  "msg": "消息"
}

##### 102 群组消息

{
  "type": 102,
  "msgSender": "发送者key",
  "msgReceiver": "接收者key",
  "msg": "消息"
}

### 2xx 系统消息

##### 201 成功连接

{
  "type": 201,
  "msgSender": "用户key",
  "msgReceiver": "无",
  "msg": "无"
}

##### 202 连接异常

{
  "type": 202,
  "msgSender": "用户key",
  "msgReceiver": "无",
  "msg": "无"
}

##### 203 好友申请

{
  "type": 203,
  "msgSender": "申请者key",
  "msgReceiver": "被申请者key",
  "msg": "无"
}

##### 204 群聊申请

{
  "type": 204,
  "msgSender": "申请者key",
  "msgReceiver": "群主key",
  "msg": "无"
}

##### 205 好友审核成功

{
  "type": 205,
  "msgSender": "同意者key",
  "msgReceiver": "申请者key",
  "msg": "无"
}

##### 206 群聊审核通过

{
  "type": 206,
  "msgSender": "申请者key",
  "msgReceiver": "群内所有人的key",
  "msg": "无"
}

##### 207 申请被拒绝

{
  "type": 207,
  "msgSender": "申请信息key",
  "msgReceiver": "被拒绝者key",
  "msg": "无"
}

# <span id="8">8 碰到的问题以及解决方法</span>

### 1 Netty的特性与设计初衷违背（设计）

Netty是一个基于事件的Nio网络通信框架，这意味着用户消息必须发送到Netty集群才能出发事件，但我设计的初衷是Netty集群仅仅充当给用户发消息的身份，用户发送消息的请求是普通请求，普通请求交付给服务器后解析然后由netty集群转发消息。

解决：

不违背初衷，让消息待处理层与Netty集群建立WebSocket连接，用户发送普通请求时，由消息待处理层发送消息到Netty集群，然后由Netty集群转发消息到对应用户。客户端建立连接成功后就会发送表示成功的消息，并附带自己的id，Netty集群接受到该消息便会存储用户Channel。

### 2 SpringBootWeb与Netty不能共存（技术）

我起初试图引入Nacos注册中心，结果一直不成功，我找到一个理由是Nacos必须结合MVC框架使用，我觉得挺有道理。于是我引入SpringBootWeb，结果还是注册不成功，于是我开始反复替换Nacos版本，最终我发现Netty的服务一旦开启（打开Netty配置类的@Component注解）Web模块就会失效。

解决：

这个问题是出于Netty开启后监听关闭阻塞线程导致的，由于Web的启动和Netty服务的创建在一条线程上，由于Netty的创建是基于PostConstruct注解，这个注解来源于Tomcat所以时机会先于SpringMVC。

继承ApplicationRunner接口而不是使用PostConstruct注解将Netty服务的创建移至SpringBoot启动后。

### 3 将SpringBoot作为WebSocket的客户端（设计）

实际操作比想象中困难，先后试了Springboot-WebSocket，okHttp等等包，都没都得到想要的效果，在使用其中一个时发生了建立连接瞬间中断的情况。

解决：

最终使用jakarta.websocket-api包成功达成目标。

<img src="https://picgotuchaung.oss-cn-beijing.aliyuncs.com/202403210850282.png" style="zoom:80%;" />

<img src="https://picgotuchaung.oss-cn-beijing.aliyuncs.com/202403210851998.png" style="zoom:80%;" />

### 4 离线消息不准确（设计）

为了防止离线消息不准确，我将离校消息从消息待处理层的业务中复制出来同时交付给Netty集群，两次交互防止消息发送失败又无法正确投递到离校消息队列中。

### 5 Dubbo工程无法支持Druid监控界面（设计）

随着 druid-spring-boot-3-starter 最新版本的发布，也是兼容了springboot3项目中的监控界面，不过本项目使用Dubbo微服务框架，这使得没有SpringBootWeb支持，当然也无法打开Druid监控界面。

解决：

不启用监控界面，改用SkyWalking进行全链路监控。	

随着8.8中设计变动，使得Druid监控台再次启用，但这与SkyWalking全链路监控并不冲突。

### 6 JWT与Netty集群信息同时存在会不会是一种数据冗余（设计）

我在用户信息组件给登录成功用户颁发完JWT的业务做完后，马上就想到了在netty与用户断开连接时，去netty删除用户Netty信息的业务中同时删去了JWT信息。那么这两种保证用户在线的信息都存储在服务端会不会造成数据冗余。

解决：

不会造成数据冗余，JWT是保证用户可以成功给服务器发送数据的凭证，而Netty信息是服务器可以成功给用户发送消息的凭证。但是当Netty失去与用户的连接时不应该同时删除用户的JWT信息，JWT失效应该采用其他方式。

### 7 JWT失效方式（设计）

JWT失效不应该与Netty状态强绑定！

解决：

（暂时只考虑BS架构）服务端发布采用长期JWT，但在客户端不对JWT进行存储，用户关闭客户端或用户退出登录即丢失JWT。

### 8 Dubbo与SpringGateway对接问题（技术）

我在微服务的部分组件中仅仅暴露了Dubbo接口，这使得无法与用户Http请求正常对接。

解决：

Dubbo文档给出多协议发布、通过网关实现协议转换两种方式。SpringWebFlux不是好的SpringWeb替代品，最终我选择多协议发布。

### 9 当缓存未命中时，数据库的查询行为是否要加锁？加本地锁还是分布式锁？（设计）

由于本业务会有极高的并发量，我打算对查询结果缓存处理以减小数据库压力。但是迎来的缓存击穿问题也是引起了我的重视。

解决：

单对于群聊功能，如果后期业务量大，可能会有数以万计的实例，缓存击穿后可能对数据库造成每秒万级并发量的访问压力。为了提防这种行为，我们对群聊添加分布式锁。

但对于好友功能，查询的数量级并不是那么多，并且好友功能中缓存的删除条件也比群聊苛刻，所以对单体好友查询仅仅添加本地锁。

对于查询申请好友记录、申请群聊记录的功能，查询的重复率低，并且添加了分页查询功能，所以不添加缓存功能。

### 10 重复添加好友，重复进群（技术）

解决：

业务中使用Set集合代替List，数据库存储用户添加好友信息表中对甲方、乙方添加唯一性索引。

### 11 用户与netty的连接问题（设计）

用户与Netty建立连接，应该先拿到对应的Netty地址，但是这地址不应该直接暴露给客户端，最好使用代理服务器，由于我们的项目中这个连接只是Netty单向发送数据给客户端，所以只需拿到对应服务器并且代理连接即可。

解决：

~~用户只需要发送Websocket请求给Gateway，由Gateway选择Netty服务器，然后建立连接。由于项目中连接后还需要发送个人消息给服务器，这个功能变迁为在http头中携带个人信息。~~

~~在随后的尝试中，出现了很多问题，我在uri上面添加了数据之后，就无法正常建立ws连接，并且netty中不能拿到请求头。于是我改变策略，想让这个数据打到微服务网关层后将数据存储并移除，随后负载均衡到Netty服务器。但是这个想法显然难度更大，无论是存储到Redis还是开辟ws连接发送数据到Netty都无法在高并发的场景下将数据和Channel绑定。所以，我们现在最大的问题就是，用户建立ws连接后无法将自己的身份标识与自己的Channel绑定，除非我不使用微服务网关，直接将Netty地址暴露出去。~~

~~或者调整负载均衡策略，使得两次ws打到同一个服务器。~~

~~连接成功时，若是后续连接不再受负载均衡影响（大概率受）即可大功告成，否则Netty集群可以发送自己的唯一标识给客户端，客户端后续携带此标识访问微服务网关，由微服务网关自定义负载均衡器决定请求转发。~~

~~实际上我们做这么多就是为了：~~

- ~~可以根据用户Key查找持有用户Channel的Netty实例~~

~~用户的key必须和Netty实例一一对应存储于Redis中，而~~

问题最终还是解决了，我在uri上面添加了数据就无法开启ws垃圾，所以我自定义了一个入站处理器，用来分离数据，分离成功后将连接再继续升级为ws连接，这个问题是我在此项目碰到的最束手无策的、尝试方法最多的问题，不过好在到此为止，项目算是完成了，后面的离线消息和消息缓存简简单单啦。

### 12 微服务网关转发WebSocket连接（技术）

我原本以为最困难的流程已经搞定了，结果花费了近2个小时没搞定SpringGateway转发ws请求。

解决：

自定义一个负载均衡过滤器

### 13 IDEA的bug导致我白忙活三天

第11条与第12条都是我为了解决微服务网关路由Netty集群的总结。其实第12条并没有彻底解决我就去写vue了，刚刚我又捡起来看了看，依旧无法路由到Netty集群，于是我试了试是不是只有Netty集群的路由，结果别的组件也路由失败，检查之下我发现负载均衡依赖一直都没成功被加载，我打开IDEA的“编辑启动器功能（新版IDEA可以使SpringBoot项目创建后依旧可以快捷添加组件的新功能）”，发现loadbalancer依赖赫然在“已加入的依赖”行列，我重新手动导入了所有的依赖。所有功能顿时全部回复正常，ws不仅能成功转发，后续网关还会继续保持长连接转发数据！！！我*了啊，我汤姆白忙活了三天。

> 其实11条不算白忙活，解决了后续微服务网关集群庞大请求打不到同一微服务网关导致无法成功登录的问题。
>
> 不过12条是纯白忙活，文档没写东西是因为我花了两天反复自定义路由断言、过滤器、阅读Gateway底层源码没有任何卵用。

至此，核心模块全部完成，仅剩离线消息与消息存储模块等待后续开发。

# <span id="9">9 接口文档（Apifox）</span>

https://apifox.com/apidoc/shared-dff6e66f-75df-49d7-9edc-9c51f731781e

# <span id="10">10 后续项目拓展思想</span>

### 1 实例拓展

docker部署，nacos分布式集群管理

### 2 数据库拓展

分库分表

### 3 缓存拓展

Redis分布式集群

### 4 消息队列拓展

多架构几个集群用nginx做负载均衡